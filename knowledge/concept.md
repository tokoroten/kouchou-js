## 概要

このアプリケーションは、Talk to the city、広聴AIをJavaScript単体で動作するように再実装したものです。

https://github.com/AIObjectives/talk-to-the-city-reports
https://github.com/digitaldemocracy2030/kouchou-ai

ブラウザ上のSPAとして動作し、サーバを不要にすることで、ポータビリティとセキュリティの向上を図っています。
大量の市民意見を効率的に分析・可視化し、政策決定者や研究者にとって有用なインサイトを提供します。

## 技術スタック

### フロントエンド
- **TypeScript** (v5.x): 型安全性の確保
- **React** (v18.x): UI構築
- **Zustand**: 軽量状態管理
- **Tailwind CSS**: ユーティリティファーストCSS
- **Vite**: 高速ビルドツール

### データ処理・分析
- **Chrome Built-in AI (Gemini Nano)**: ローカルテキスト処理・要約・分類
- **Sentence Transformers JS**: ローカルエンベディング生成
- **UMAP-js**: 高次元データの低次元可視化　https://www.npmjs.com/package/umap-js
- **K-means**: クラスタリングアルゴリズム
- **plotly.js**: インタラクティブなデータ可視化

### データ永続化・非同期処理
- **IndexedDB**: ブラウザ内データストレージ
- **Web Workers**: CPU集約的処理の非同期実行
- **Papa Parse**: CSV解析ライブラリ

### 開発環境
- **Node.js** (v20.x)
- **ESLint**: コード品質管理
- **Prettier**: コードフォーマッタ

## アプリケーションの動作の流れ

### 1. セッション管理
#### 入力
- ユーザーの新規セッション開始リクエスト
- 既存セッション情報（継続の場合）

#### 処理
- **セッション初期化**: 新しい分析開始時にUUIDを生成し、セッションを開始
- **永続化**: セッション状態はIndexedDBで永続化され、ブラウザを閉じても継続可能
- **マルチセッション**: 複数の分析セッションを並行して管理
- **モデル共有**: 過去のセッションからUMAPモデルを再利用し、一貫した可視化を実現

#### 出力
- セッションUUID
- セッション設定オブジェクト
- IndexedDBへの永続化完了通知

### 2. データ入力・前処理
#### 入力
- CSVファイル（意見データ + 発言者属性）
- カラム選択設定（意見カラム、属性カラムの指定）

#### 処理
- **CSVアップロード**: 
  - 意見データと発言者属性を含むCSVファイルの処理
  - 必須カラム: `opinion`（意見内容）
  - オプションカラム: `age`, `gender`, `region`, `category` など
  - どのカラムが分析対象の意見カラムで、どのカラムが属性情報かをユーザーが選択可能
- **データ検証**: 
  - アップロード時にデータ形式とカラム構造を自動検証
  - エラー詳細の表示と修正提案
- **プレビュー機能**: アップロード後にデータ内容とサンプルを表示

#### 出力
- 検証済み構造化データ（JSON）
- データ統計情報（行数、カラム数、データ型）
- エラーレポート（該当する場合）
- データサンプル（プレビュー用）

### 3. 意見処理パイプライン（Web Worker実行）

#### 3.1 発言の成形
- **入力**: 生意見データ（CSV解析済み構造化データ）
- **出力**: 構造化された意見リスト（JSON形式）
- **目的**: 生データから構造化された意見を抽出
- **処理**: Chrome Built-in AI (Gemini Nano)を使用して意見を正規化・分割を行う
  - rewriteで文体を丁寧語に変換
  - 特定の話題に関して、個人情報を除去し、意見を自動で分割を行うように、調整する
- **効果**: エンベディング処理の品質向上とノイズ除去、個人情報の除去、攻撃性の除去

#### 3.2 意見のエンベディング

- **入力**: 構造化された意見リスト（JSON形式）
- **出力**: 
  - エンベディングベクトル配列（数値配列）
  - 意見とエンベディングのマッピング情報
  - キャッシュ情報（ハッシュと結果のペア）
- **モデル**: Sentence TransformersのJS版を使用
  - https://www.npmjs.com/package/@tuesdaycrowd/sentence-transformers
  - ダウンロードしたモデルはIndexedDBに保存、キャッシュする
- **キャッシュ**: 同一意見の再計算を避けるためのハッシュベースキャッシュを実装
- **非同期処理**: Web Workerでエンベディングを並列実行


#### 3.3 次元削減（UMAP）
- **入力**: エンベディングベクトル配列（高次元数値配列）
- **出力**: 
  - 2次元座標配列（x, y座標ペア）
  - 学習済みUMAPモデル（シリアライズ済み）
  - 変換パラメータと統計情報
- **設定可能パラメータ**:
  - `n_neighbors`: 近傍数（デフォルト: 15）
  - `min_dist`: 最小距離（デフォルト: 0.1）
  - `n_components`: 出力次元（固定: 2）
- **モデル再利用**: 学習済みUMAPモデルの保存・読み込み機能
- **インクリメンタル処理**: 新データの追加時の効率的な処理

#### 3.4 クラスタリング（K-means）
- **入力**: 2次元座標配列（UMAP変換済み）
- **出力**: 
  - クラスタ割り当て配列（各意見のクラスタID）
  - クラスタ重心座標
  - クラスタ統計情報（サイズ、密度）
- **クラスタ数決定**: クラスタ数はユーザ指定、デフォルト値は int((データ数)^(1/3)) 程度
- **ユーザー設定**: 手動でのクラスタ数指定も可能
- **安定性**: 複数回実行による結果の安定化

#### 3.5 意見の表札化と要約
- **入力**: 
  - クラスタ割り当て配列
  - 2次元座標配列
  - 構造化された意見リスト
- **出力**:
  - 各クラスタの代表意見配列
  - クラスタラベル・概念
  - クラスタ別要約
  - 全体要約
- **代表意見選出アルゴリズム**:
  1. クラスタ重心に最も近い意見を選出
  2. 既存選出意見から最も遠い意見を追加選出
  3. n回繰り返し（デフォルト: n=5）
- **階層的要約**:
  - クラスタレベル: Chrome Built-in AI (Gemini Nano)で代表意見から概念とラベルを生成
  - 全体レベル: 各クラスタ要約を統合した総括をGemini Nanoで生成
  - フォールバック: Gemini Nano利用不可時はルールベース要約

### 4. 可視化・エクスポート

#### 4.1 インタラクティブ可視化
- **入力**:
  - 2次元座標配列
  - クラスタ割り当て配列
  - クラスタラベル・概念
  - 意見の属性情報
- **出力**:
  - インタラクティブな散布図（HTML）
  - 可視化設定オブジェクト
  - フィルタリング・ズーム状態
- **機能**:
  - **plotly.js使用**: ズーム、パン、ホバー情報
  - **カラーマッピング**: クラスタ別の色分け
  - **アノテーション**: クラスタ重心にラベル表示
  - **フィルタリング**: 属性による動的フィルタ機能

#### 4.2 レポート生成
- **入力**:
  - 可視化オブジェクト
  - 全体要約・クラスタ要約
  - 分析パラメータ設定
  - セッション情報
- **出力**:
  - スタンドアロンHTMLレポート
  - CSV形式分析データ
  - 設定ファイル（JSON）
- **機能**:
  - **HTML出力**: スタンドアロンで動作する完全なレポート
  - **CSV出力**: 分析結果の数値データ
  - **設定の保存**: 分析パラメータの再現可能性確保

## 技術的詳細

### Web Worker活用戦略
各処理ステップを独立したWorkerで実行し、UIの応答性を維持：

```
Main Thread              Worker Threads
     │                        │
     ├── UI Management         ├── CSV Parser Worker
     ├── State Management      ├── LLM Processing Worker  
     ├── Visualization         ├── Embedding Worker
     └── IndexedDB Access      ├── UMAP Worker
                              └── Clustering Worker
```

各Workerは処理完了時にIndexedDBに結果を保存し、メインスレッドに通知します。

### データ永続化戦略
- **セッション管理**: UUID別のセッションテーブル
- **段階的保存**: 各処理ステップの結果をインクリメンタルに保存
- **モデル共有**: UMAPモデルのシリアライゼーションと再利用
- **キャッシュ最適化**: エンベディングのハッシュベースキャッシュ

### エラーハンドリング・信頼性
- **段階的復旧**: 途中で中断された処理の継続機能
- **Gemini Nano フォールバック**: Chrome Built-in AI利用不可時の代替処理
- **データ検証**: 各段階でのデータ整合性チェック
- **ログ機能**: デバッグとエラー追跡のための詳細ログ

## ユーザーインターフェース設計

### 画面構成
1. **ダッシュボード**: セッション一覧と進行状況の概要
2. **アップロード画面**: CSV入力とデータプレビュー
3. **設定画面**: Gemini Nano設定とパラメータ調整
4. **処理画面**: リアルタイム進行状況とログ表示
5. **可視化画面**: インタラクティブな結果表示
6. **エクスポート画面**: レポート生成とダウンロード

### UX配慮事項
- **進行状況の可視化**: 各処理ステップの詳細な進捗表示
- **中断・再開**: 長時間処理の柔軟な管理
- **プリセット機能**: よく使用される設定の保存・読み込み
- **レスポンシブ対応**: デスクトップ・タブレットでの最適表示

## パフォーマンス最適化

### 処理効率化
- **バッチ処理**: API呼び出しの効率的なグループ化
- **並列処理**: 独立した処理の並列実行
- **メモリ管理**: 大容量データのストリーミング処理
- **プログレッシブ表示**: 結果の段階的な表示更新

### スケーラビリティ
- **データサイズ制限**: 推奨データサイズとワーニング機能
- **動的リソース調整**: 利用可能メモリに応じた処理調整
- **バックグラウンド処理**: タブを閉じても継続する処理機能

## Gemini Nano 実装戦略

### Chrome Built-in AI 統合
- **API利用**: Chrome Built-in AI API (実験的機能)
- **対象機能**: 意見成形、要約生成、ラベル作成
- **利点**: APIキー不要、完全無料、プライバシー保護
- **制約**: Chrome Canary/Dev版での開発が必要

### 機能別実装アプローチ

#### 1. 意見成形（Gemini Nano）
```typescript
interface OpinionProcessor {
  // 意見の正規化・分割
  processRawOpinions(rawText: string): Promise<CleanOpinion[]>;
  // 個人情報除去
  removePersonalInfo(opinion: string): Promise<string>;
  // 攻撃的内容のフィルタリング
  moderateContent(opinion: string): Promise<string>;
}
```

#### 2. 要約・ラベル生成（Gemini Nano）
```typescript
interface SummaryGenerator {
  // クラスタ要約生成
  generateClusterSummary(opinions: CleanOpinion[]): Promise<string>;
  // クラスタラベル作成
  createClusterLabel(opinions: CleanOpinion[]): Promise<string>;
  // 全体要約生成
  generateOverallSummary(clusterSummaries: string[]): Promise<string>;
}
```

#### 3. エンベディング（Sentence Transformers JS）
```typescript
interface EmbeddingGenerator {
  // ローカルエンベディング生成
  generateEmbeddings(opinions: CleanOpinion[]): Promise<number[][]>;
  // モデルキャッシュ管理
  loadModel(): Promise<void>;
}
```

